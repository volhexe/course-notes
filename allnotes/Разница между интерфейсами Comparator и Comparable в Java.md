В Java **Comparable** и **Comparator** — это интерфейсы, которые используются для сравнения объектов, но они применяются в разных сценариях. Они помогают сортировать коллекции или определять порядок элементов. 
#### 1. Интерфейс Comparable
- **Назначение**: Определяет **естественный порядок** сравнения для класса. Объекты одного типа сравниваются между собой по умолчанию.
- **Метод**: Реализует метод `int compareTo(T other)`, который сравнивает текущий объект с другим.
  - Возвращает: `-1` (текущий < other), `0` (равны), `1` (текущий > other).
- **Применение**: Используется в классах вроде `String`, `Integer`, где сравнение логично по умолчанию (например, алфавит для строк).
- **Пример**: Предположим, у нас есть класс `Person` с естественной сортировкой по возрасту.

  ```java
  class Person implements Comparable<Person> {
      private String name;
      private int age;
      
      // Конструктор и геттеры
      
      @Override
      public int compareTo(Person other) {
          return Integer.compare(this.age, other.age);
      }
  }
  ```
- **Сравнение**: Только один способ сортировки на класс.

#### 2. Интерфейс Comparator
- **Назначение**: Позволяет сравнивать объекты **по нужному критерию**, часто для гибкой сортировки без изменения класса. Не изменяет естественный порядок.
- **Метод**: Реализует метод `int compare(T o1, T o2)` в отдельном классе или анонимно.
  - То же возвращает: `-1`, `0`, `1`.
- **Применение**: Идеально для сортировки `Person` по имени вместо возраста, или для коллекций с сложными критериями. Используется с методами вроде `Collections.sort(list, comparator)`.
- **Пример**: Для класса `Person` создаём компаратор по имени.

  ```java
  Comparator<Person> nameComparator = new Comparator<Person>() {
      @Override
      public int compare(Person p1, Person p2) {
          return p1.getName().compareTo(p2.getName());
      }
  };
  
  // Использование: List<Person> people = ...; Collections.sort(people, nameComparator);
  ```
- **Сравнение**: Можно иметь несколько компараторов для одного класса (например, по имени, возрасту, зарплате).

#### Ключевые отличия
- **Интеграция**: 
  - `Comparable`: Встраивается в класс (нужен модификатор `implements`).
  - `Comparator`: Отдельный класс или lambda, не меняет исходный класс.
- **Гибкость**: 
  - `Comparable`: Один естественный порядок.
  - `Comparator`: Множественные стратегии сравнения.
- **Использование**: 
  - `Comparable`: Автоматическая сортировка (в TreeSet, Arrays.sort без компаратора).
  - `Comparator`: Ручное указание при сортировке.
- **Когда выбирать**:
  - `Comparable`: Если естественный порядок понятен (например, числа).
  - `Comparator`: Для кастомной сортировки или когда класс неизменяем.