RetentionPolicy — это настройка для аннотаций (те "меток" в коде, которые начинаются с `@`, как `@Override` или `@Component` в Spring). Она определяет, **насколько долго аннотация "живёт" в вашем приложении**: скомпилируется ли она в bytecode (машинный код Java) и будет ли видна во время выполнения программы. 

В Java есть три варианта RetentionPolicy: `SOURCE`, `CLASS` и `RUNTIME`. Представьте аннотацию как наклейку на коробке: где она сохраняется — на этикетке, в коробке или и дальше?

#### 1. **RetentionPolicy.SOURCE** (только на этапе разработки)
   - **Что происходит**: Аннотация используется только кодером или компилятором во время написания/компиляции. После компиляции она полностью удаляется — в .class-файле (bytecode) её нет, и во время запуска программы она не видна.
   - **Простой пример**: `@Override` — говорит компилятору: "Проверь, что этот метод переопределяет родительский". Если всё ок, наклейка снимается. Полезно для проверок на этапе сборки, чтобы код был чище.
   - **Когда использовать**: Для рефакторинга или статических проверок (например, @Deprecated). Экономит место и ускоряет загрузку класса.
   - **Минус**: Программа не может "увидеть" эту аннотацию в runtime (во время работы).

#### 2. **RetentionPolicy.CLASS** (сохраняется в bytecode, но не в runtime)
   - **Что происходит**: Аннотация записывается в .class-файл (bytecode), но **НЕ доступна во время выполнения** (JVM не загружает её в память). Это как наклейка внутри коробки — компилятор и инструменты (например, IDE) её видят, но программа на запуске — нет.
   - **Простой пример**: Аннотации для инструментов вроде @Target или @Retention (мета-аннотации). Они нужны для анализа кода статически, но не влияют на работу приложения.
   - **Когда использовать**: Редко, для bridge-аннотаций или инструментов вроде байт-код манипуляторов (ASM, Javassist). Это средний вариант: больше, чем SOURCE, но не тратит ресурсы в runtime.
   - **Минус**: Нет доступа через рефлексию (Reflection API) в коде.

#### 3. **RetentionPolicy.RUNTIME** (сохраняется и доступна во время работы)
   - **Что происходит**: Аннотация полностью сохраняется — в bytecode и в памяти во время выполнения. Программа может "прочитать" её с помощью рефлексии (методами вроде `getAnnotation()`). Это как наклейка, которая остаётся на коробке навсегда и видна всем.
   - **Простой пример**: `@SpringBootApplication` или `@Autowired` в Spring — во время запуска Spring "сканирует" код, читает эти аннотации и использует их для создания бинов (объектов). Без RUNTIME ничего не сработает.
   - **Когда использовать**: Для фреймворков (Spring, Hibernate, Lombok), где код " //!<" динамически анализирует аннотации. Большинство пользовательских аннотаций в реальных проектах — RUNTIME.
   - **Минус**: Чуть больше нагрузки на JVM (загрузка метаданных).

#### Ключевые различия в таблице (для ясности)
| RetentionPolicy | Доступ в коде (IDE) | В bytecode (.class) | В runtime (запущенное app) | Примеры |
|---------------|---------------------|---------------------|----------------------------|---------|
| **SOURCE**   | Да                  | Нет                 | Нет                        | @Override, @SuppressWarnings |
| **CLASS**    | Да                  | Да                  | Нет                        | @Target, @Retention (мета) |
| **RUNTIME**  | Да                  | Да                  | Да                         | @Component, @RestController |
